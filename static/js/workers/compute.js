"use strict"; function doFill(msg, reqId) { const { w: w, h: h, sx: sx, sy: sy, fillR: fillR, fillG: fillG, fillB: fillB, tol: tol } = msg, d = new Uint8ClampedArray(msg.data), ref = msg.refData ? new Uint8ClampedArray(msg.refData) : d, x0 = Math.floor(sx), y0 = Math.floor(sy); if (x0 < 0 || x0 >= w || y0 < 0 || y0 >= h) return void self.postMessage({ type: "done", reqId: reqId, data: d.buffer }, [d.buffer]); const i0 = 4 * (y0 * w + x0), tr = ref[i0], tg = ref[i0 + 1], tb = ref[i0 + 2], ta = ref[i0 + 3]; if (tr === fillR && tg === fillG && tb === fillB && 255 === ta) return void self.postMessage({ type: "done", reqId: reqId, data: d.buffer }, [d.buffer]); const m = i => Math.abs(ref[i] - tr) <= tol && Math.abs(ref[i + 1] - tg) <= tol && Math.abs(ref[i + 2] - tb) <= tol && Math.abs(ref[i + 3] - ta) <= tol, vis = new Uint8Array(w * h), q = [y0 * w + x0]; for (vis[y0 * w + x0] = 1; q.length;) { const pi = q.pop(), px = pi % w, py = pi / w | 0; let lx = px; for (; lx > 0 && !vis[py * w + lx - 1] && m(4 * (py * w + lx - 1));)lx--, vis[py * w + lx] = 1; let rx = px; for (; rx < w - 1 && !vis[py * w + rx + 1] && m(4 * (py * w + rx + 1));)rx++, vis[py * w + rx] = 1; for (let x = lx; x <= rx; x++) { const i = 4 * (py * w + x); d[i] = fillR, d[i + 1] = fillG, d[i + 2] = fillB, d[i + 3] = 255; for (const ny of [py - 1, py + 1]) if (ny >= 0 && ny < h) { const ni = ny * w + x; !vis[ni] && m(4 * ni) && (vis[ni] = 1, q.push(ni)) } } } self.postMessage({ type: "done", reqId: reqId, data: d.buffer }, [d.buffer]) } function doBlur(msg, reqId) { const { w: w, h: h, radius: radius } = msg, d = new Uint8ClampedArray(msg.data), o = new Uint8ClampedArray(d.length), r = radius; for (let y = 0; y < h; y++)for (let x = 0; x < w; x++) { let sr = 0, sg = 0, sb = 0, sa = 0, c = 0; for (let dy = -r; dy <= r; dy++)for (let dx = -r; dx <= r; dx++) { const nx = x + dx, ny = y + dy; if (nx >= 0 && nx < w && ny >= 0 && ny < h) { const i = 4 * (ny * w + nx); sr += d[i], sg += d[i + 1], sb += d[i + 2], sa += d[i + 3], c++ } } const i = 4 * (y * w + x); o[i] = sr / c, o[i + 1] = sg / c, o[i + 2] = sb / c, o[i + 3] = sa / c } self.postMessage({ type: "done", reqId: reqId, data: o.buffer }, [o.buffer]) } function doEraserClip(msg, reqId) { self.postMessage({ type: "done", reqId: reqId, result: "ok" }) } function doGif(msg, reqId) { const { w: w, h: h, framesData: framesData, delay: delay } = msg, cm = new Map, cols = [], ac = (r, g, b) => { const k = r << 16 | g << 8 | b; !cm.has(k) && cols.length < 255 && (cm.set(k, cols.length), cols.push([r, g, b])) }; for (const fd of framesData) { const d = new Uint8Array(fd); for (let i = 0; i < d.length; i += 4)ac(248 & d[i], 248 & d[i + 1], 248 & d[i + 2]) } for (; cols.length < 256;)cols.push([0, 0, 0]); const nr = (r, g, b, a) => { if (a < 128) return 255; const k = (r &= 248) << 16 | (g &= 248) << 8 | (b &= 248); if (cm.has(k)) return cm.get(k); let best = 0, bd = 1e9; for (let i = 0; i < cols.length - 1; i++) { const dr = r - cols[i][0], dg = g - cols[i][1], db = b - cols[i][2], d2 = dr * dr + dg * dg + db * db; d2 < bd && (bd = d2, best = i) } return best }, buf = [], wr = b => buf.push(b), ws = s => { for (let i = 0; i < s.length; i++)wr(s.charCodeAt(i)) }, wsh = v => { wr(255 & v), wr(v >> 8 & 255) }; ws("GIF89a"), wsh(w), wsh(h), wr(247), wr(0), wr(0); for (let i = 0; i < 256; i++)wr(cols[i][0]), wr(cols[i][1]), wr(cols[i][2]); wr(33), wr(255), wr(11), ws("NETSCAPE2.0"), wr(3), wr(1), wsh(0), wr(0); for (let fi = 0; fi < framesData.length; fi++) { const d = new Uint8Array(framesData[fi]); wr(33), wr(249), wr(4), wr(9), wsh(Math.round(delay / 10)), wr(255), wr(0), wr(44), wsh(0), wsh(0), wsh(w), wsh(h), wr(0), wr(8); const px = new Uint8Array(w * h); for (let i = 0; i < w * h; i++) { const j = 4 * i; px[i] = nr(d[j], d[j + 1], d[j + 2], d[j + 3]) } const sb = lzw(8, px); for (const b of sb) { wr(b.length); for (const x of b) wr(x) } wr(0), self.postMessage({ type: "progress", reqId: reqId, frame: fi + 1, total: framesData.length }) } wr(59); const r = new Uint8Array(buf); self.postMessage({ type: "done", reqId: reqId, data: r.buffer }, [r.buffer]) } function lzw(mcs, px) { const cc = 1 << mcs, ei = cc + 1; let cs = mcs + 1, nc = ei + 1; const tb = new Map, rst = () => { tb.clear(); for (let i = 0; i < cc; i++)tb.set(String(i), i); nc = ei + 1, cs = mcs + 1 }, out = []; let bb = 0, bc = 0; const em = c => { for (bb |= c << bc, bc += cs; bc >= 8;)out.push(255 & bb), bb >>= 8, bc -= 8 }; rst(), em(cc); let cur = String(px[0]); for (let i = 1; i < px.length; i++) { const nx = String(px[i]), cb = cur + "," + nx; tb.has(cb) ? cur = cb : (em(tb.get(cur)), nc <= 4095 ? (tb.set(cb, nc++), nc > 1 << cs && cs < 12 && cs++) : (em(cc), rst()), cur = nx) } em(tb.get(cur)), em(ei), bc > 0 && out.push(255 & bb); const blocks = []; for (let i = 0; i < out.length; i += 255)blocks.push(out.slice(i, i + 255)); return blocks } self.onmessage = function (e) { const { type: type, reqId: reqId } = e.data; "floodFill" === type ? doFill(e.data, reqId) : "gifEncode" === type ? doGif(e.data, reqId) : "blur" === type ? doBlur(e.data, reqId) : "eraserClip" === type && doEraserClip(e.data, reqId) };